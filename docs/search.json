[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Andrew Setiono, S. Psi, M. Si",
    "section": "",
    "text": "Andrew Setiono, S. Psi, M. Si\nI am a recent graduate from the Research Master program at the Faculty of Behavioral and Social Sciences, University of Groningen.\n\n\n\n\nPassionate about understanding and solving complex organizational phenomena, I specialize in advanced statistical methods with a focus on multilevel modeling.\n\n\nMy research interests span topics such as hybrid work, workplace aging, and the influence of family-supportive leadership."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Andrew’s Blog",
    "section": "",
    "text": "Unlocking Indonesia’s Workforce: A Practical Guide to the BPS (Bureau of Statistics) API in R\n\n\n\nTutorial\n\nR\n\nAPI\n\nBPS\n\nAging Workforce\n\n\n\nA step-by-step guide to accessing and visualizing workforce data in Indonesia using the BPS API in R. Learn how to retrieve, parse, and visualize data on the aging workforce…\n\n\n\n\n\n\nJul 8, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nBetter Approaches to Performance Monitoring\n\n\n\nI/O Psych\n\nEssay\n\n\n\nEmployee performance monitoring can crucial in talent retention and productivity maintenance—especially with a disengaged workforce—but they are often intrusive and…\n\n\n\n\n\n\nJun 3, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-06-post1/index.html",
    "href": "posts/2023-06-post1/index.html",
    "title": "Better Approaches to Performance Monitoring",
    "section": "",
    "text": "As employers of a global company, the ‘great resignation’ and ‘quiet quitting’ have become the forefront of workplace issues that warrants concern. A recent survey from McKinsey reported that 40% of the global workforce is somewhat likely to leave their current jobs (De Smet et al., 2021). Another report from Gallup (2022) revealed that only 21% of global workers are engaged at work. The same report also showed that nearly 5 out of 10 workers experience worry and stress daily at work. These reports presented the challenging landscape of retaining talents and maintaining their engagement.\nTo thrive against these challenging work trends as a global company, an effective employee performance monitoring may prove to be essential. Employee performance monitoring entails various workplace practices that allow the collection of performance data from employees (Stanton, 2000). Such performance data may allow employers to identify which employees display high performance and should be retained. Furthermore, it may reveal which employees are showing signs of disengagement. Recently, these practices have been rapidly developing—from traditional to electronic performance monitoring—due to digital transformation within companies and the pandemic. Stanton (2000) highlighted that electronic monitoring differs from traditional monitoring, especially in its ability to collect performance data; electronic monitoring allows continuous monitoring of multiple dimensions of work performance, whereas traditional monitoring requires the presence of human observers. Furthermore, electronic has an obvious advantage of remote monitoring which aids employers during the pandemic.\nDespite its apparent advantages, employees are pushing back against intrusive and demanding performance monitoring (Kantor et al., 2022). oday, both white- and blue-collar workers are dealing with monitoring software that invades their privacy (e.g., software that takes photos at multiple random times a day) and interferes with their focus (e.g., “idle” buttons). Furthermore, they are dealing with micro-managing leaders who demand multiple, but often unnecessary, status reports. Moreover, these practices have been taken to the extent that employees are unable to do essential offline work (e.g., deep thinking, reading printouts, talking to customers) or breaks (e.g., bathroom breaks) without receiving a reprimand from the software or their leaders (e.g., through constant check-in, notifications, or emails).\nThis trend of employees’ pushback indicates the mounting pressure to maintain productivity among employers. However, it also revealed that employers are unaware of how employees would react to monitoring system features. Therefore, understanding the underlying psychological process employees experience under performance monitoring would likely result in a competitive advantage over other companies. Furthermore, such understanding would allow for designing an effective monitoring system.\nResearch in organizational psychology may provide a framework and insights to move forward. Specifically, adapting Carayon’s (1993) framework, employee performance monitoring is proposed to influence employee well-being through job design. Job designs are further divided into three key components: (1) job demand, (2) job control, and (3) social support. In the following paragraphs, these components will be extended to gain a deeper understanding employees’ psychological process."
  },
  {
    "objectID": "posts/2023-06-post1/index.html#performance-monitoring-and-job-demand",
    "href": "posts/2023-06-post1/index.html#performance-monitoring-and-job-demand",
    "title": "Better Approaches to Performance Monitoring",
    "section": "Performance monitoring and job demand",
    "text": "Performance monitoring and job demand\nCarayon’s (1993) framework proposed that performance monitoring could affect the level of stress that employees experience through its influence on job demand. Employees reported that monitoring software often tracks their mouse movements and keyboard clicks, which forces them to be constantly working or active, or else they would be marked with inactivity (Kantor et al., 2022). This is an example of real-time performance tracker that characterizes current performance monitoring. Under constant pressure, employees may perceive an increase in their job demands (i.e., high time pressure and workload), thus increasing stress. Indeed, the pressure to be constantly “on” can be seen as a form of task-related job stressor (Sonnentag & Frese, 2012, p. 562), which could reduce employee well-being (Green, 2004).\nFurthermore, the constant pressure that performance monitoring imposes on employees may prevent them from recovering and potentially prolong their stress responses which would be harmful in the long run. According to DiStaso and Shoss (2020), employees need to perceive an “end” state of their current workload (e.g., employees only need to clock in for 40 hours of work per week, project timelines indicating when it would be finished). They found that anticipating a workload decrease would help employees buffer against the negative effect of workload stressors. However, the typical characteristic of performance monitoring that interferes with “idle” times (e.g., bathroom breaks, talking to family or colleagues) may prevent employees from seeing the proverbial “light at the end of the tunnel.” Thus, exacerbating the negative effect of the workload."
  },
  {
    "objectID": "posts/2023-06-post1/index.html#performance-monitoring-and-control",
    "href": "posts/2023-06-post1/index.html#performance-monitoring-and-control",
    "title": "Better Approaches to Performance Monitoring",
    "section": "Performance monitoring and control",
    "text": "Performance monitoring and control\nAnother important factor that is influenced by performance monitoring is employees’ enactment of control at work. Drawing from Kotabe and Hofmann (2015) Integrative Self-Control Theory (ISCT), we conclude that there are three possible avenues of performance monitoring effect on employee behavioral enactment: (1) control motivation, (2) control capacity, and (3) enactment constraints.\nThe first avenue, control motivation, is defined as the personal “aspiration to control desire” (Kotabe & Hofmann, 2015, p. 624). Lian et al. (2017) noted that individuals are motivated to engage in self-control at work based on its expected consequences. Control motivation is then closely related to performance monitoring. Performance monitoring communicates which behaviors are rewarded (or punished), allowing employees to evaluate the value and consequence of their behaviors.\nThe second avenue, control capacity, pertains to individuals’ resources that enable them to override desire (Kotabe & Hofmann, 2015). It was found to be closely linked with executive functions and relied on direct attention—a depletable and restorable resource (Kaplan & Berman, 2010). Performance monitoring has the potential to redirect or deplete attention. In the former case, performance monitoring may direct employees’ attention to work dimensions that need further improvement, thus helping them refocus self-control effort to enhance task performance. In the latter case, intrusive performance monitoring can potentially distract employees from focusing on work or essential tasks. Jeske and Santuzzi (2015) found that close performance monitoring reduce employees perceived control. Furthermore, performance monitoring only directs attention to those tasks that are being monitored, thus depleting resources from other tasks (Ravid et al., 2020).\nThe last avenue, enactment constraint, represents the contextual factors that restrict behavioral options (Kotabe & Hofmann, 2015). This contextual restriction is related to Carayon’s (1993) idea of job control as the mediator between performance monitoring and stress. Specifically, Carayon (1993) argued that some features of performance monitoring might influence the level of control that employees have over their pace of work (i.e., instrumental control) or how tasks are executed and expected (i.e., conceptual control). Indeed, we saw that intrusive performance monitoring could make employees feel dictated. For instance, Kantor et al. (2022) reported how performance monitoring software dictates hospice chaplains’ relationships with the dying; they sometimes have to change the nature of their relationships (e.g., shifted time and quality of relationship) to meet the standard determined by the software."
  },
  {
    "objectID": "posts/2023-06-post1/index.html#performance-monitoring-and-social-support",
    "href": "posts/2023-06-post1/index.html#performance-monitoring-and-social-support",
    "title": "Better Approaches to Performance Monitoring",
    "section": "Performance Monitoring and Social Support",
    "text": "Performance Monitoring and Social Support\nSocial support is the last component of job design that mediates the effect of performance monitoring (Carayon, 1993). Carayon (1993) argued that specific characteristics of the performance monitoring system might change the nature of social support employees receive from supervisors. Anecdotal examples of managers who immediately notify their workers after brief “Away” periods or constantly ask for progress updates from their subordinates (Tatum, 2022), are indicative of the changes in the nature of leader’s support. These changes may happen because performance monitoring systems shape how leaders and their subordinates construe their power (Sewell et al., 2012). The availability of an intrusive monitoring system may possibly obscure the leader’s sense of social connection to their employees since leaders primarily interact with their employees through the performance metric. This severing of social connection thus reduces the social support that leaders provide to their subordinates, leaving them with increasing work pressure but low support."
  },
  {
    "objectID": "posts/2023-06-post1/index.html#design-monitoring-systems-that-allows-recovery",
    "href": "posts/2023-06-post1/index.html#design-monitoring-systems-that-allows-recovery",
    "title": "Better Approaches to Performance Monitoring",
    "section": "Design Monitoring Systems that Allows Recovery",
    "text": "Design Monitoring Systems that Allows Recovery\nAs discussed, the monitoring system can increase employee stress because it increases job demand and has the potential to reduce control capacity from essential tasks. One way to reduce these adverse effects is to avoid constant monitoring and embed recovery time or break into the monitoring system. Short breaks allow employees to replenish control capacity (Lian et al., 2017). Furthermore, it is vital that the system not only allows for recovery but also promotes awareness for employees that they will have recovery. Anticipation of a workload decrease (i.e., availability of recovery time) may buffer employees from experiencing negative emotions in the current high workload condition (DiStaso & Shoss, 2020).\nEmbedding recovery times to the monitoring system can be done by allowing “idle” time that is considered reasonable for taking breaks. For example, Amazon has relaxed its performance monitoring regulations by dropping off the term “time off task” and instructing their managers to only look for “idle” periods longer than 15 minutes. Moreover, the monitoring system can be designed to stop when certain conditions are met, therefore creating the anticipation of a decrease in workload. For instance, instead of designing a monitoring system that continuously tracks mouse activities, employers may opt for a monitoring system that can be turned off after certain working hours or goals are met."
  },
  {
    "objectID": "posts/2023-06-post1/index.html#involve-employees-while-designing-monitoring-system",
    "href": "posts/2023-06-post1/index.html#involve-employees-while-designing-monitoring-system",
    "title": "Better Approaches to Performance Monitoring",
    "section": "Involve Employees while Designing Monitoring System",
    "text": "Involve Employees while Designing Monitoring System\nIntensive monitoring system can sometimes be perceived as “demoralizing” and not accurately reflect the nature of work that employees are going through (Kantor et al., 2022). These reports might be indicative that monitoring system are often designed with the purpose of surveillance and punishment. In other words, the system is designed without a rationale beyond collecting employee information or without employees interest of pursuing their work goals. These may create perceptions of low control among employees and increase work pressure and stress. Instead of leaving out employees from the design process, creating opportunities for discussion and providing legitimate justification as to why the monitoring should exist may be more useful.\nWithin the discussion process, employees may provide information about which tasks should be considered as important to be monitored. Furthermore, employees can provide ideas as to how their performance should ideally be monitored. By giving opportunities for discussing the monitoring process, employees perceive that they have some level of control toward their job, thus increasing job control. Additionally, employee should be provided with justification for the monitoring system. Justification of system tend to produce positive response, such as greater feelings of justice, in those being monitored (Ravid et al., 2020)."
  },
  {
    "objectID": "posts/2023-06-post1/index.html#empower-leaders-to-be-responsible-to-others",
    "href": "posts/2023-06-post1/index.html#empower-leaders-to-be-responsible-to-others",
    "title": "Better Approaches to Performance Monitoring",
    "section": "Empower Leaders to be Responsible to Others",
    "text": "Empower Leaders to be Responsible to Others\nLeaders hold a strategic position in a performance monitoring system as they hold the power to manage and discipline their subordinates (Sewell et al., 2012). However, as discussed above, one must be cautious about how the performance monitoring system influences a leader’s construal of their power. An intrusive monitoring system may reduce social connections, thus severing the relational aspect of power. Tost and Johnson (2019) argued that leaders who failed to construe the relational aspect of power would refrain from investing their resources to benefit members of the group. Consequently, it is important to influence leaders to construe their power as a responsibility to be stewards of their subordinates.\nOne way to change a leader’s power construal is to introduce, develop, or strengthen benevolent power norms and dependency awareness. Tost and Johnson (2019) found that benevolent power norms mediated the relationship between structural power and responsibility. Benevolent power norms may inform leaders of the expectation that they should use performance monitoring (i.e., a form of structural power) to benefit the interests of employees. Furthermore, leaders should be made aware that their subordinates are also dependent on leaders’ access to performance monitoring to evaluate their performances and determine ways to enhance them."
  },
  {
    "objectID": "posts/2025-07-post1/index.html",
    "href": "posts/2025-07-post1/index.html",
    "title": "Unlocking Indonesia’s Workforce: A Practical Guide to the BPS (Bureau of Statistics) API in R",
    "section": "",
    "text": "Getting an accurate and up-to-date understanding of the workforce in Indonesia is crucial for researchers, policymakers, and the general public. The Badan Pusat Statistik (BPS) Indonesia (Bureau of Statistics Indonesia) provides a wealth of data through its API.\nThis guide will walk you through the process of accessing and visualizing workforce data in Indonesia using the BPS API in R. We will focus on the “Angkatan kerja menurut golongan umur” (Workforce by Age Group) dataset for the year 2025, which is particularly relevant given the general trend of aging workforce worldwide (World Economic Forum, 2025)."
  },
  {
    "objectID": "docs/posts/2025-07-post2/index.html",
    "href": "docs/posts/2025-07-post2/index.html",
    "title": "Is Indonesia Workfore Aging?",
    "section": "",
    "text": "In my previous post, I have shown how we can interact with the BPS API to get the latest data on Indonesia’s workforce. Using this knowledge, we will now explore whether Indonesia does indeed have an aging workforce.\nOne way to demonstrate an aging workforce is to look for a widening gap between the number of workers in the 15-24 age group and the number of workers in the 60+ age group over time. If the gap is widening, it suggests that there are fewer young workers entering the workforce compared to older workers who are retiring.\nTo do so, we need to explore the BPS API data across years. I will examine Indonesia’s workforce data between 2008-2025 because this is the earliest year for which the BPS API provides data, and 2025 is the latest year for which we have data.\n\nQuick API extraction\nIn the previous post, I have shown how to extract data from the BPS API.\n\nlibrary(httr2)\nlibrary(tidyverse)\n\nWe use the same approach to extract the data we need. However, this time we will expand on the th (year) parameter to include all years from 2008 to 2025. The BPS API allows us to specify the year we want to retrieve data for, so we can loop through the years and collect the data for each year.\n\napi_key &lt;- Sys.getenv(\"BPS_API_KEY\")\nbase_url &lt;- \"https://webapi.bps.go.id/v1/api/list\"\n\nmodel &lt;- \"data\" \nlang &lt;- \"ind\" \ndomain &lt;- \"0000\" \nvar &lt;- \"698\" \nth_years &lt;- seq(108, 125) # Years from 2008 to 2025\n\nWe create a custom function to make the API request for each year and return the data in a tidy format.\n\nmake_bps_request_for_year &lt;- function(\n    year, base_url, api_key, model, lang, domain, var\n) {\n  request(base_url) |&gt;\n    req_url_path_append(\n      \"model\", model,\n      \"lang\", lang,\n      \"domain\", domain,\n      \"var\", var,\n      \"th\", as.character(year), # Pass the current 'year' from the loop\n      \"key\", api_key\n    ) |&gt;\n    req_perform()\n}\n\nNow we can loop through the years and collect the data for each year. We will use map_dfr from the purrr package to iterate over the years and combine the results into a single data frame.\n\napi_responses_list &lt;- purrr::map(th_years, function(year) {\n  message(paste(\"Fetching data for year:\", year))\n  make_bps_request_for_year(\n    year = year,\n    base_url = base_url,\n    api_key = api_key,\n    model = model,\n    lang = lang,\n    domain = domain,\n    var = var\n  )\n})\n\nFetching data for year: 108\n\n\nFetching data for year: 109\n\n\nFetching data for year: 110\n\n\nFetching data for year: 111\n\n\nFetching data for year: 112\n\n\nFetching data for year: 113\n\n\nFetching data for year: 114\n\n\nFetching data for year: 115\n\n\nFetching data for year: 116\n\n\nFetching data for year: 117\n\n\nFetching data for year: 118\n\n\nFetching data for year: 119\n\n\nFetching data for year: 120\n\n\nFetching data for year: 121\n\n\nFetching data for year: 122\n\n\nFetching data for year: 123\n\n\nFetching data for year: 124\n\n\nFetching data for year: 125\n\n\nWe can see that the API responses are stored in a list. Each element of the list corresponds to a year and contains the data for that year.\n\n\n[[1]]\n\n\n&lt;httr2_response&gt;\n\n\nGET\nhttps://webapi.bps.go.id/v1/api/list/model/data/lang/ind/domain/0000/var/698/th/108/key/2c0878a4b13ca251e15d588238f17adc\n\n\nStatus: 200 OK\n\n\nContent-Type: application/json\n\n\nBody: In memory (7194 bytes)\n\n\n\n[[2]]\n\n\n&lt;httr2_response&gt;\n\n\nGET\nhttps://webapi.bps.go.id/v1/api/list/model/data/lang/ind/domain/0000/var/698/th/109/key/2c0878a4b13ca251e15d588238f17adc\n\n\nStatus: 200 OK\n\n\nContent-Type: application/json\n\n\nBody: In memory (7192 bytes)\n\n\nNext, we will extract the content from each API response. We define a custom function to extract the data from the API response. This function checks if the request was successful and then extracts the body of the response, which is expected to be in JSON format.\n\nextracted_data_list &lt;- purrr::map(api_responses_list, function(response) {\n  if (httr2::resp_status(response) == 200) {\n    resp_body &lt;- httr2::resp_body_json(response)\n    return(resp_body)\n  } else {\n    warning(paste(\n      \"Request failed for one year with status:\", \n      httr2::resp_status(response)))\n    return(NULL) # Return NULL or an error indicator for failed requests\n  }\n})\n\nJust like before, we can use map_dfr to combine the extracted data into a single data frame. We need to extract the datacontent from the extracted data, which contains the actual data we are interested in.\n\nbps_data &lt;- purrr::map_dfr(extracted_data_list, function(data) {\n  if (!is.null(data)) {\n    datacontent &lt;- data$datacontent\n    return(enframe(datacontent))\n  } else {\n    return(NULL) # Return NULL for failed requests\n  }\n})\n\nNow we have a data frame bps_data that contains the workforce data for Indonesia from 2008 to 2025. The data frame has two columns: name and value. The name column contains the key which contains the relevant year and employment status data once parsed, and the value column contains the corresponding values.\n\n\n# A tibble: 6 × 2\n  name           value    \n  &lt;chr&gt;          &lt;list&gt;   \n1 11698828108190 &lt;int [1]&gt;\n2 6698830108189  &lt;dbl [1]&gt;\n3 10698828108190 &lt;int [1]&gt;\n4 4698830108189  &lt;dbl [1]&gt;\n5 3698828108190  &lt;int [1]&gt;\n6 7698828108190  &lt;int [1]&gt;\n\n\nWe can recall our parse_key function from the previous post to parse the name column into separate columns for year, employment status, and age group.\n\nparse_key &lt;- function(key) {\n \n  vervar_val &lt;- substr(key, 1, nchar(key) - 12)\n  var_val &lt;- substr(key, nchar(key) - 11, nchar(key) - 9)\n  turvar_val &lt;- substr(key, nchar(key) - 8, nchar(key) - 6) \n  tahun_val &lt;- substr(key, nchar(key) - 5, nchar(key) - 3)\n  turtahun_val &lt;- substr(key, nchar(key) - 2, nchar(key))\n\n  return(\n    list(\n      vervar = vervar_val,\n      var = var_val,\n      turvar = turvar_val,\n      tahun = tahun_val,\n      turtahun = turtahun_val\n    )\n  )\n}\n\n\nbps_data_tidy &lt;- bps_data |&gt; \n  mutate(\n   value = as.double(value),\n   parsed_key = map(name, parse_key)\n  ) |&gt; \n  unnest_wider(parsed_key) |&gt; \n  select(-c(name, var)) |&gt;\n  rename(\n    age_group = vervar,\n    value = value,\n    employment_status = turvar,\n    year = tahun,\n    month = turtahun\n  ) |&gt; \n  select(\n    year, month, age_group, employment_status, value\n  )\n\nhead(bps_data_tidy)\n\n# A tibble: 6 × 5\n  year  month age_group employment_status     value\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;                 &lt;dbl&gt;\n1 108   190   11        828               9394515  \n2 108   189   6         830                    95.0\n3 108   190   10        828                 84600  \n4 108   189   4         830                    92.8\n5 108   190   3         828               1759409  \n6 108   190   7         828                196379  \n\n\nNow, we have a tidy data frame bps_data_tidy that contains the workforce data for Indonesia from 2008 to 2025. Now, we can label the age_group and employement_status columns to make them more readable. Because we are looking at multiple dataset across years, there is a possibility that each of them have different labels. We will create a function that extracts the unique labels from the API responses for each parameters (e.g., vervar, turvar) and returns them as a named vector.\n\nextract_unique_labels &lt;- function(api_response_list, element_name) {\n\n  if (is.null(api_response_list) || length(api_response_list) == 0) {\n    message(\"Input API response list is empty or NULL for element '\", \n            element_name, \"'. Returning NULL.\")\n    return(NULL)\n  }\n\n  # Remove any NULL responses (e.g., from failed API calls) before processing\n  clean_response_list &lt;- purrr::compact(api_response_list)\n\n  if (length(clean_response_list) == 0) {\n    message(\"No valid (non-NULL) API responses to process for element '\", \n            element_name, \"' after compacting. Returning NULL.\")\n    return(NULL)\n  }\n\n  all_labels_df &lt;- clean_response_list |&gt;\n    purrr::map_dfr(\\(x) {\n      target_element &lt;- x[[element_name]]\n      if (is.null(target_element) || length(target_element) == 0) {\n        return(tibble(val = numeric(0), label = character(0))) \n      }\n\n      purrr::map_dfr(target_element, ~ tibble(\n        val = as.numeric(.x$val), \n        label = as.character(.x$label)))\n    })\n\n  # Final processing: unique rows, then pull\n  if (nrow(all_labels_df) == 0) {\n    message(paste(\"No unique labels found for element:\", \n                  element_name, \". Returning NULL.\"))\n    return(NULL)\n  }\n\n  unique_named_vector &lt;- all_labels_df |&gt;\n    dplyr::distinct(val, label) |&gt; # Use distinct() for unique rows\n    dplyr::pull(label, name = val)\n\n  return(unique_named_vector)\n}\n\nWe can now use this function to extract the unique labels for each of the parameters we are interested in: vervar, turvar, turtahun, and tahun.\n\nvervar_labels &lt;- extract_unique_labels(extracted_data_list, \"vervar\") \nturvar_labels &lt;- extract_unique_labels(extracted_data_list, \"turvar\") \nturtahun_labels &lt;- extract_unique_labels(extracted_data_list, \"turtahun\")\ntahun_labels &lt;- extract_unique_labels(extracted_data_list, \"tahun\")\n\nNow, we can relabel the tidy data frame bps_data_tidy using the extracted labels. We will use the recode function from the dplyr package to relabel the age_group and employement_status columns.\n\nbps_data_tidy_labeled &lt;- bps_data_tidy |&gt; \n  mutate(\n    age_group = recode(age_group, !!!vervar_labels),\n    employment_status = recode(employment_status, !!!turvar_labels),\n    year = recode(year, !!!tahun_labels),\n    month = recode(month, !!!turtahun_labels) \n  ) |&gt; \n  mutate(\n    age_group = factor(age_group, levels = c(\n      \"15-19\", \"20-24\", \"25-29\", \"30-34\", \"35-39\", \n      \"40-44\", \"45-49\", \"50-54\", \"55-59\", \"60+\", \"Total\"\n    ), ordered = TRUE\n    ),\n    month = factor(month, levels = c(\n      \"Januari\", \"Februari\", \"Maret\", \"April\", \n      \"Mei\", \"Juni\", \"Juli\", \"Agustus\", \n      \"September\", \"Oktober\", \"November\", \"Desember\",\n      \"Tahunan\"\n    )),\n    employment_status = factor(employment_status, levels = c(\n      \"Bekerja\", \"Jumlah Pengangguran\", \"Jumlah AK\", \"% Bekerja / AK\"\n    )),\n  ) |&gt; \n  select(year, month, employment_status, age_group, value) |&gt; \n  arrange(year, month, employment_status, age_group)\n\nAnd, here is a sample of the labeled data frame:\n\n\n# A tibble: 10 × 5\n   year  month    employment_status age_group    value\n   &lt;chr&gt; &lt;fct&gt;    &lt;fct&gt;             &lt;ord&gt;        &lt;dbl&gt;\n 1 2008  Februari Bekerja           15-19      5734328\n 2 2008  Februari Bekerja           20-24     11332576\n 3 2008  Februari Bekerja           25-29     13351202\n 4 2008  Februari Bekerja           30-34     13566222\n 5 2008  Februari Bekerja           35-39     13146274\n 6 2008  Februari Bekerja           40-44     11998948\n 7 2008  Februari Bekerja           45-49     10484959\n 8 2008  Februari Bekerja           50-54      8238848\n 9 2008  Februari Bekerja           55-59      5804677\n10 2008  Februari Bekerja           60+        8391823\n\n\n\n\nVisualizing the data\nWe can now visualize the data to see if there is indeed an aging workforce in Indonesia. We will create a line plot that shows the number of workers in the 15-24 age group and the number of workers in the 60+ age group over time.\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Bekerja\",\n    month != \"Tahunan\"\n  ) |&gt; \n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n    facet_wrap(~ month, scales = \"free_y\") +\n    geom_line(size = 1) +\n    geom_point(size = 2) +\n    scale_color_manual(values = c(\n      \"20-24\" = \"#E69F00\", # Muted orange\n      \"55-59\" = \"#56B4E9\", # Sky blue\n      \"60+\" = \"#009E73\"  # Bluish green\n    )) +\n    labs(\n    title = \"Working Individuals in Indonesia by Age Group (2008-2025)\",\n    x = \"Year\",\n  ) +\n  scale_y_continuous(\n    \"Number of workers\", \n    labels = scales::label_number(scale_cut = scales::cut_long_scale())\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1)\n  )\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nThis plot shows the number of workers in the 20-24 age group and the 60+ age group over time. We can see that the number of workers in the 20-24 age group has been decreasing over time, while the number of workers in the 60+ age group has been increasing. This suggests that there is indeed an aging workforce in Indonesia.\nWe can further show this widening gap by centering all the values against 2008 numbers for each age group. This would further clarify whether there is a wdineing gap between the two age groups.\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Bekerja\",\n    month != \"Tahunan\"\n  ) |&gt; \n  group_by(age_group, month) |&gt; \n  mutate(value = value - value[year == 2008]) |&gt; \n  ungroup() |&gt; \n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n    facet_wrap(~ month, scales = \"free_y\") +\n    geom_line(size = 1) +\n    geom_point(size = 2) +\n    scale_color_manual(values = c(\n      \"20-24\" = \"#E69F00\", # Muted orange\n      \"55-59\" = \"#56B4E9\", # Sky blue\n      \"60+\" = \"#009E73\"  # Bluish green\n    )) +\n    labs(\n      title = \"Working Individuals in Indonesia by Age Group (2008-2025)\",\n      x = \"Year\",\n      y = \"Change in Number of Workers (compared to 2008)\",\n      color = \"Age Group\"\n    ) +\n    scale_y_continuous(\n      labels = scales::label_number(scale_cut = scales::cut_long_scale())\n    ) +\n    theme_minimal() +\n    theme(\n      axis.text.x = element_text(angle = 90, hjust = 1)\n    )\n\n\n\n\n\n\n\n\nThis plot shows the change in the number of workers in the 20-24 age group and the 60+ age group compared to 2008. We can see that the number of workers in the 20-24 age group has been decreasing over time, while the number of workers in the 60+ age group has been increasing. This further confirms that there is indeed an aging workforce in Indonesia.\nHow about the overall workforce, do we also see the same trend?\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Jumlah AK\",\n    month != \"Tahunan\"\n  ) |&gt; \n  group_by(age_group, month) |&gt; \n  mutate(value = value - value[year == 2008]) |&gt; \n  ungroup() |&gt; \n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n    facet_wrap(~ month, scales = \"free_y\") +\n    geom_line(size = 1) +\n    geom_point(size = 2) +\n    scale_color_manual(values = c(\n      \"20-24\" = \"#E69F00\", # Muted orange\n      \"55-59\" = \"#56B4E9\", # Sky blue\n      \"60+\" = \"#009E73\"  # Bluish green\n    )) +\n    labs(\n      title = \"Workforce in Indonesia by Age Group (2008-2025)\",\n      x = \"Year\",\n      y = \"Change in Number of Workers (compared to 2008)\",\n      color = \"Age Group\"\n    ) +\n    scale_y_continuous(\n      labels = scales::label_number(scale_cut = scales::cut_long_scale())\n    ) +\n    theme_minimal() +\n    theme(\n      axis.text.x = element_text(angle = 90, hjust = 1)\n    )\n\n\n\n\n\n\n\n\nThis plot shows the change in the total number of workers in the 20-24 age group and the 60+ age group compared to 2008. We can see that the number of workers in the 20-24 age group has been decreasing over time, while the number of workers in the 60+ age group has been increasing. This further confirms that there is indeed an aging workforce in Indonesia.\nBut, how about the unemployed?\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Jumlah Pengangguran\",\n    month != \"Tahunan\"\n  ) |&gt; \n  group_by(age_group, month) |&gt; \n  mutate(value = value - value[year == 2008]) |&gt; \n  ungroup() |&gt; \n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n    facet_wrap(~ month, scales = \"free_y\") +\n    geom_line(size = 1) +\n    geom_point(size = 2) +\n    scale_color_manual(values = c(\n      \"20-24\" = \"#E69F00\", # Muted orange\n      \"55-59\" = \"#56B4E9\", # Sky blue\n      \"60+\" = \"#009E73\"  # Bluish green\n    )) +\n    labs(\n      title = \"Unemployment in Indonesia by Age Group (2008-2025)\",\n      x = \"Year\",\n      y = \"Change in Number of Unemployed (compared to 2008)\",\n      color = \"Age Group\" \n    ) +\n    scale_y_continuous(\n      labels = scales::label_number(scale_cut = scales::cut_long_scale())\n    ) +\n    theme_minimal() +\n    theme(\n      axis.text.x = element_text(angle = 90, hjust = 1)\n    )"
  },
  {
    "objectID": "posts/2025-07-post1/index.html#getting-the-api-token",
    "href": "posts/2025-07-post1/index.html#getting-the-api-token",
    "title": "Unlocking Indonesia’s Workforce: A Practical Guide to the BPS (Bureau of Statistics) API in R",
    "section": "Getting the API Token",
    "text": "Getting the API Token\nThe BPS API provides access to various data sets from the Badan Pusat Statistik (BPS) Indonesia (Bureau of Statistics Indonesia).\nTo use the API, you need an API key, which you can obtain by registering on the BPS website. Log in to your BPS account, fill out your profile details, and create an application in the “Applications” tab Figure 1.\nOnce you have created an application, you will see your API token in the “App ID” column. You can copy this token and set it as an environment variable. I recommend storing this key in the .Renviron file in your R project directory, so you can access it easily in your R scripts.\n\napi_key &lt;- Sys.getenv(\"BPS_API_KEY\")\n\n\n\n\n\n\n\nFigure 1: Application tabs in the BPS Web API Profile"
  },
  {
    "objectID": "posts/2025-07-post1/index.html#making-api-requests",
    "href": "posts/2025-07-post1/index.html#making-api-requests",
    "title": "Unlocking Indonesia’s Workforce: A Practical Guide to the BPS (Bureau of Statistics) API in R",
    "section": "Making API Requests",
    "text": "Making API Requests\nNext, we develop our API request. We start by specifying the base URL for the API which is: https://webapi.bps.go.id/v1/api/list\n\nbase_url &lt;- \"https://webapi.bps.go.id/v1/api/list\"\n\nThe BPS API provides a variety of endpoints to access different data sets. The base URL is followed by specific parameters that define the data you want to retrieve.\nAccording to the API documentation, to retrieve data you need to specify the following parameters: model, domain, var, and th. Unfortunately, the documentation does not provide a comprehensive list of available variables and its corresponding data set, so you will need to explore the API to find the data you want.\nOne way to specify the right API request is to find the data you want to retrieve using the BPS website, and inspect the API request template to that data by clicking on the JSON button Figure 2. This will give you an idea of the structure of the data and the parameters you need for your API request.\n\n\n\n\n\n\nFigure 2: Click on the JSON button\n\n\n\nIn our example, we want to access the data for the “Angkatan kerja menurut golongan umur” (Workforce by Age Group) for the year 2025. Clicking on the JSON button, we can see the API endpoint that retrieves this data is:\n\n\"https://webapi.bps.go.id/v1/api/list/model/data/lang/ind/domain/0000/var/698/th/125/key/[WebAPI_KEY]\"\n\n\n\n\n\n\n\nNote\n\n\n\nThe [WebAPI_KEY] part of the URL is a placeholder for your actual API key. You need to replace it with your own API key to make the request work.\n\n\nFrom this endpoint, we can modify our api request parameters using the req_url_path_append() function from the httr2 package. The parameters we will use are:\n\nmodel &lt;- \"data\" # model for \"Data\"\nlang &lt;- \"ind\" # language for \"Bahasa Indonesia\"\ndomain &lt;- \"0000\" # domain for \"Pusat\"\nvar &lt;- \"698\" # variable for table \"Angkatan kerja menurut golongan umur\"\nth &lt;- \"125\" # tahun 2025\n\napi_response &lt;- request(base_url) |&gt;\n  req_url_path_append(\n    \"model\", model,\n    \"lang\", lang,\n    \"domain\", domain,\n    \"var\", var,\n    \"th\", 125,\n    \"key\", api_key\n  ) |&gt;\n  req_perform()\n\nBelow is the response from the API request. The response is in JSON format, which we can parse to extract the data we need using resp_body_json() function.\n\napi_response_list &lt;- api_response |&gt; resp_body_json()\nglimpse(api_response_list)\n\n\n\nList of 12\n $ status           : chr \"OK\"\n $ data-availability: chr \"available\"\n $ last_update      : chr \"2025-06-25 10:04:27\"\n $ subject          :List of 1\n  ..$ :List of 2\n  .. ..$ val  : int 520\n  .. ..$ label: chr \"Tenaga Kerja\"\n $ var              :List of 1\n  ..$ :List of 7\n  .. ..$ val    : int 698\n  .. ..$ label  : chr \"Angkatan Kerja (AK) Menurut Golongan Umur\"\n  .. ..$ unit   : chr \"\"\n  .. ..$ subj   : chr \"Tenaga Kerja\"\n  .. ..$ def    : chr \"\"\n  .. ..$ decimal: int 2\n  .. ..$ note   : chr \"&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br \"| __truncated__\n $ turvar           :List of 4\n  ..$ :List of 2\n  .. ..$ val  : int 827\n  .. ..$ label: chr \"Bekerja\"\n  ..$ :List of 2\n  .. ..$ val  : int 828\n  .. ..$ label: chr \"Jumlah Pengangguran\"\n  ..$ :List of 2\n  .. ..$ val  : int 829\n  .. ..$ label: chr \"Jumlah AK\"\n  ..$ :List of 2\n  .. ..$ val  : int 830\n  .. ..$ label: chr \"% Bekerja / AK\"\n $ labelvervar      : chr \"Golongan Umur\"\n $ vervar           :List of 11\n  ..$ :List of 2\n  .. ..$ val  : int 1\n  .. ..$ label: chr \"15-19\"\n  ..$ :List of 2\n  .. ..$ val  : int 2\n  .. ..$ label: chr \"20-24\"\n  ..$ :List of 2\n  .. ..$ val  : int 3\n  .. ..$ label: chr \"25-29\"\n  ..$ :List of 2\n  .. ..$ val  : int 4\n  .. ..$ label: chr \"30-34\"\n  ..$ :List of 2\n  .. ..$ val  : int 5\n  .. ..$ label: chr \"35-39\"\n  ..$ :List of 2\n  .. ..$ val  : int 6\n  .. ..$ label: chr \"40-44\"\n  ..$ :List of 2\n  .. ..$ val  : int 7\n  .. ..$ label: chr \"45-49\"\n  ..$ :List of 2\n  .. ..$ val  : int 8\n  .. ..$ label: chr \"50-54\"\n  ..$ :List of 2\n  .. ..$ val  : int 9\n  .. ..$ label: chr \"55-59\"\n  ..$ :List of 2\n  .. ..$ val  : int 10\n  .. ..$ label: chr \"60+\"\n  ..$ :List of 2\n  .. ..$ val  : int 11\n  .. ..$ label: chr \"Total\"\n $ tahun            :List of 1\n  ..$ :List of 2\n  .. ..$ val  : int 125\n  .. ..$ label: chr \"2025\"\n $ turtahun         :List of 3\n  ..$ :List of 2\n  .. ..$ val  : int 189\n  .. ..$ label: chr \"Februari\"\n  ..$ :List of 2\n  .. ..$ val  : int 190\n  .. ..$ label: chr \"Agustus\"\n  ..$ :List of 2\n  .. ..$ val  : int 191\n  .. ..$ label: chr \"Tahunan\"\n $ datacontent      :List of 44\n  ..$ 7698827125189 : int 16164793\n  ..$ 2698828125189 : int 2527741\n  ..$ 4698828125189 : int 619800\n  ..$ 9698828125189 : int 262632\n  ..$ 7698829125189 : int 16450825\n  ..$ 3698828125189 : int 1319299\n  ..$ 4698830125189 : num 96.4\n  ..$ 6698828125189 : int 332935\n  ..$ 1698827125189 : int 4724711\n  ..$ 3698829125189 : int 17703447\n  ..$ 5698828125189 : int 351093\n  ..$ 11698830125189: num 95.2\n  ..$ 1698830125189 : num 82.2\n  ..$ 1698829125189 : int 5746898\n  ..$ 6698829125189 : int 17107389\n  ..$ 2698830125189 : num 84.4\n  ..$ 11698829125189: int 153049487\n  ..$ 1698828125189 : int 1022187\n  ..$ 8698829125189 : int 14323589\n  ..$ 11698827125189: int 145771180\n  ..$ 8698828125189 : int 242764\n  ..$ 5698827125189 : int 17177085\n  ..$ 2698829125189 : int 16224936\n  ..$ 11698828125189: int 7278307\n  ..$ 4698827125189 : int 16799939\n  ..$ 5698830125189 : int 98\n  ..$ 4698829125189 : int 17419739\n  ..$ 9698827125189 : int 11512218\n  ..$ 2698827125189 : int 13697195\n  ..$ 5698829125189 : int 17528178\n  ..$ 10698828125189: int 313824\n  ..$ 8698827125189 : int 14080825\n  ..$ 9698830125189 : num 97.8\n  ..$ 10698830125189: num 98.3\n  ..$ 7698830125189 : num 98.3\n  ..$ 7698828125189 : int 286032\n  ..$ 6698827125189 : int 16774454\n  ..$ 6698830125189 : num 98\n  ..$ 3698827125189 : int 16384148\n  ..$ 8698830125189 : num 98.3\n  ..$ 9698829125189 : int 11774850\n  ..$ 10698829125189: int 18769636\n  ..$ 10698827125189: int 18455812\n  ..$ 3698830125189 : num 92.5\n $ related          : list()"
  },
  {
    "objectID": "posts/2025-07-post2/index.html",
    "href": "posts/2025-07-post2/index.html",
    "title": "Is Indonesia Workfore Aging?",
    "section": "",
    "text": "In my previous post, I have shown how we can interact with the BPS API to get the latest data on Indonesia’s workforce. Using this knowledge, we will now explore whether Indonesia does indeed have an aging workforce.\nOne way to demonstrate an aging workforce is to look for a widening gap between the number of workers in the 15-24 age group and the number of workers in the 60+ age group over time. If the gap is widening, it suggests that there are fewer young workers entering the workforce compared to older workers who are retiring.\nTo do so, we need to explore the BPS API data across years. I will examine Indonesia’s workforce data between 2008-2025 because this is the earliest year for which the BPS API provides data, and 2025 is the latest year for which we have data.\n\nQuick API extraction\nIn the previous post, I have shown how to extract data from the BPS API.\n\nlibrary(httr2)\nlibrary(tidyverse)\n\nWe use the same approach to extract the data we need. However, this time we will expand on the th (year) parameter to include all years from 2008 to 2025. The BPS API allows us to specify the year we want to retrieve data for, so we can loop through the years and collect the data for each year.\n\napi_key &lt;- Sys.getenv(\"BPS_API_KEY\")\nbase_url &lt;- \"https://webapi.bps.go.id/v1/api/list\"\n\nmodel &lt;- \"data\"\nlang &lt;- \"ind\"\ndomain &lt;- \"0000\"\nvar &lt;- \"698\"\nth_years &lt;- seq(108, 125) # Years from 2008 to 2025\n\nWe create a custom function to make the API request for each year and return the data in a tidy format.\n\nmake_bps_request_for_year &lt;- function(\n    year, base_url, api_key, model, lang, domain, var) {\n  request(base_url) |&gt;\n    req_url_path_append(\n      \"model\", model,\n      \"lang\", lang,\n      \"domain\", domain,\n      \"var\", var,\n      \"th\", as.character(year), # Pass the current 'year' from the loop\n      \"key\", api_key\n    ) |&gt;\n    req_perform()\n}\n\nNow we can loop through the years and collect the data for each year. We will use map_dfr from the purrr package to iterate over the years and combine the results into a single data frame.\n\napi_responses_list &lt;- purrr::map(th_years, function(year) {\n  message(paste(\"Fetching data for year:\", year))\n  make_bps_request_for_year(\n    year = year,\n    base_url = base_url,\n    api_key = api_key,\n    model = model,\n    lang = lang,\n    domain = domain,\n    var = var\n  )\n})\n\nFetching data for year: 108\n\n\nFetching data for year: 109\n\n\nFetching data for year: 110\n\n\nFetching data for year: 111\n\n\nFetching data for year: 112\n\n\nFetching data for year: 113\n\n\nFetching data for year: 114\n\n\nFetching data for year: 115\n\n\nFetching data for year: 116\n\n\nFetching data for year: 117\n\n\nFetching data for year: 118\n\n\nFetching data for year: 119\n\n\nFetching data for year: 120\n\n\nFetching data for year: 121\n\n\nFetching data for year: 122\n\n\nFetching data for year: 123\n\n\nFetching data for year: 124\n\n\nFetching data for year: 125\n\n\nWe can see that the API responses are stored in a list. Each element of the list corresponds to a year and contains the data for that year.\nNext, we will extract the content from each API response. We define a custom function to extract the data from the API response. This function checks if the request was successful and then extracts the body of the response, which is expected to be in JSON format.\n\nextracted_data_list &lt;- purrr::map(api_responses_list, function(response) {\n  if (httr2::resp_status(response) == 200) {\n    resp_body &lt;- httr2::resp_body_json(response)\n    return(resp_body)\n  } else {\n    warning(paste(\n      \"Request failed for one year with status:\",\n      httr2::resp_status(response)\n    ))\n    return(NULL) # Return NULL or an error indicator for failed requests\n  }\n})\n\nJust like before, we can use map_dfr to combine the extracted data into a single data frame. We need to extract the datacontent from the extracted data, which contains the actual data we are interested in.\n\nbps_data &lt;- purrr::map_dfr(extracted_data_list, function(data) {\n  if (!is.null(data)) {\n    datacontent &lt;- data$datacontent\n    return(enframe(datacontent))\n  } else {\n    return(NULL) # Return NULL for failed requests\n  }\n})\n\nNow we have a data frame bps_data that contains the workforce data for Indonesia from 2008 to 2025. The data frame has two columns: name and value. The name column contains the key which contains the relevant year and employment status data once parsed, and the value column contains the corresponding values.\n\n\n# A tibble: 6 × 2\n  name           value    \n  &lt;chr&gt;          &lt;list&gt;   \n1 11698828108190 &lt;int [1]&gt;\n2 6698830108189  &lt;dbl [1]&gt;\n3 10698828108190 &lt;int [1]&gt;\n4 4698830108189  &lt;dbl [1]&gt;\n5 3698828108190  &lt;int [1]&gt;\n6 7698828108190  &lt;int [1]&gt;\n\n\nWe can recall our parse_key function from the previous post to parse the name column into separate columns for year, employment status, and age group.\n\nparse_key &lt;- function(key) {\n  vervar_val &lt;- substr(key, 1, nchar(key) - 12)\n  var_val &lt;- substr(key, nchar(key) - 11, nchar(key) - 9)\n  turvar_val &lt;- substr(key, nchar(key) - 8, nchar(key) - 6)\n  tahun_val &lt;- substr(key, nchar(key) - 5, nchar(key) - 3)\n  turtahun_val &lt;- substr(key, nchar(key) - 2, nchar(key))\n\n  return(\n    list(\n      vervar = vervar_val,\n      var = var_val,\n      turvar = turvar_val,\n      tahun = tahun_val,\n      turtahun = turtahun_val\n    )\n  )\n}\n\n\nbps_data_tidy &lt;- bps_data |&gt;\n  mutate(\n    value = as.double(value),\n    parsed_key = map(name, parse_key)\n  ) |&gt;\n  unnest_wider(parsed_key) |&gt;\n  select(-c(name, var)) |&gt;\n  rename(\n    age_group = vervar,\n    value = value,\n    employment_status = turvar,\n    year = tahun,\n    month = turtahun\n  ) |&gt;\n  select(\n    year, month, age_group, employment_status, value\n  )\n\nhead(bps_data_tidy)\n\n# A tibble: 6 × 5\n  year  month age_group employment_status     value\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;                 &lt;dbl&gt;\n1 108   190   11        828               9394515  \n2 108   189   6         830                    95.0\n3 108   190   10        828                 84600  \n4 108   189   4         830                    92.8\n5 108   190   3         828               1759409  \n6 108   190   7         828                196379  \n\n\nNow, we have a tidy data frame bps_data_tidy that contains the workforce data for Indonesia from 2008 to 2025. Now, we can label the age_group and employement_status columns to make them more readable. Because we are looking at multiple dataset across years, there is a possibility that each of them have different labels. We will create a function that extracts the unique labels from the API responses for each parameters (e.g., vervar, turvar) and returns them as a named vector.\n\nextract_unique_labels &lt;- function(api_response_list, element_name) {\n  if (is.null(api_response_list) || length(api_response_list) == 0) {\n    message(\n      \"Input API response list is empty or NULL for element '\",\n      element_name, \"'. Returning NULL.\"\n    )\n    return(NULL)\n  }\n\n  # Remove any NULL responses (e.g., from failed API calls) before processing\n  clean_response_list &lt;- purrr::compact(api_response_list)\n\n  if (length(clean_response_list) == 0) {\n    message(\n      \"No valid (non-NULL) API responses to process for element '\",\n      element_name, \"' after compacting. Returning NULL.\"\n    )\n    return(NULL)\n  }\n\n  all_labels_df &lt;- clean_response_list |&gt;\n    purrr::map_dfr(\\(x) {\n      target_element &lt;- x[[element_name]]\n      if (is.null(target_element) || length(target_element) == 0) {\n        return(tibble(val = numeric(0), label = character(0)))\n      }\n\n      purrr::map_dfr(target_element, ~ tibble(\n        val = as.numeric(.x$val),\n        label = as.character(.x$label)\n      ))\n    })\n\n  # Final processing: unique rows, then pull\n  if (nrow(all_labels_df) == 0) {\n    message(paste(\n      \"No unique labels found for element:\",\n      element_name, \". Returning NULL.\"\n    ))\n    return(NULL)\n  }\n\n  unique_named_vector &lt;- all_labels_df |&gt;\n    dplyr::distinct(val, label) |&gt; # Use distinct() for unique rows\n    dplyr::pull(label, name = val)\n\n  return(unique_named_vector)\n}\n\nWe can now use this function to extract the unique labels for each of the parameters we are interested in: vervar, turvar, turtahun, and tahun.\n\nvervar_labels &lt;- extract_unique_labels(extracted_data_list, \"vervar\")\nturvar_labels &lt;- extract_unique_labels(extracted_data_list, \"turvar\")\nturtahun_labels &lt;- extract_unique_labels(extracted_data_list, \"turtahun\")\ntahun_labels &lt;- extract_unique_labels(extracted_data_list, \"tahun\")\n\nNow, we can relabel the tidy data frame bps_data_tidy using the extracted labels. We will use the recode function from the dplyr package to relabel the age_group and employement_status columns.\n\nbps_data_tidy_labeled &lt;- bps_data_tidy |&gt;\n  mutate(\n    age_group = recode(age_group, !!!vervar_labels),\n    employment_status = recode(employment_status, !!!turvar_labels),\n    year = recode(year, !!!tahun_labels),\n    month = recode(month, !!!turtahun_labels)\n  ) |&gt;\n  mutate(\n    age_group = factor(age_group, levels = c(\n      \"15-19\", \"20-24\", \"25-29\", \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\", \"60+\", \"Total\"\n    ), ordered = TRUE),\n    month = factor(month, levels = c(\n      \"Januari\", \"Februari\", \"Maret\", \"April\",\n      \"Mei\", \"Juni\", \"Juli\", \"Agustus\",\n      \"September\", \"Oktober\", \"November\", \"Desember\",\n      \"Tahunan\"\n    )),\n    employment_status = factor(employment_status, levels = c(\n      \"Bekerja\", \"Jumlah Pengangguran\", \"Jumlah AK\", \"% Bekerja / AK\"\n    )),\n  ) |&gt;\n  select(year, month, employment_status, age_group, value) |&gt;\n  arrange(year, month, employment_status, age_group)\n\nAnd, here is a sample of the labeled data frame:\n\n\n# A tibble: 10 × 5\n   year  month    employment_status age_group    value\n   &lt;chr&gt; &lt;fct&gt;    &lt;fct&gt;             &lt;ord&gt;        &lt;dbl&gt;\n 1 2008  Februari Bekerja           15-19      5734328\n 2 2008  Februari Bekerja           20-24     11332576\n 3 2008  Februari Bekerja           25-29     13351202\n 4 2008  Februari Bekerja           30-34     13566222\n 5 2008  Februari Bekerja           35-39     13146274\n 6 2008  Februari Bekerja           40-44     11998948\n 7 2008  Februari Bekerja           45-49     10484959\n 8 2008  Februari Bekerja           50-54      8238848\n 9 2008  Februari Bekerja           55-59      5804677\n10 2008  Februari Bekerja           60+        8391823\n\n\n\n\nVisualizing the data\nWe can now visualize the data to see if there is indeed an aging workforce in Indonesia. We will create a line plot that shows the number of workers in the 15-24 age group and the number of workers in the 60+ age group over time.\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Bekerja\",\n    month != \"Tahunan\"\n  ) |&gt;\n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n  facet_wrap(~month, scales = \"free_y\") +\n  geom_line(size = 1) +\n  geom_point(size = 2) +\n  scale_color_manual(values = c(\n    \"20-24\" = \"#E69F00\", # Muted orange\n    \"55-59\" = \"#56B4E9\", # Sky blue\n    \"60+\" = \"#009E73\" # Bluish green\n  )) +\n  labs(\n    title = \"Working Individuals in Indonesia by Age Group (2008-2025)\",\n    x = \"Year\",\n  ) +\n  scale_y_continuous(\n    \"Number of workers\",\n    labels = scales::label_number(scale_cut = scales::cut_long_scale())\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1)\n  )\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nThis plot shows the number of workers in the 20-24 age group and the 60+ age group over time. We can see that the number of workers in the 20-24 age group has been decreasing over time, while the number of workers in the 60+ age group has been increasing. This suggests that there is indeed an aging workforce in Indonesia.\nWe can further show this widening gap by centering all the values against 2008 numbers for each age group. This would further clarify whether there is a wdineing gap between the two age groups.\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Bekerja\",\n    month != \"Tahunan\"\n  ) |&gt;\n  group_by(age_group, month) |&gt;\n  mutate(value = value - value[year == 2008]) |&gt;\n  ungroup() |&gt;\n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n  facet_wrap(~month, scales = \"free_y\") +\n  geom_line(size = 1) +\n  geom_point(size = 2) +\n  scale_color_manual(values = c(\n    \"20-24\" = \"#E69F00\", # Muted orange\n    \"55-59\" = \"#56B4E9\", # Sky blue\n    \"60+\" = \"#009E73\" # Bluish green\n  )) +\n  labs(\n    title = \"Working Individuals in Indonesia by Age Group (2008-2025)\",\n    x = \"Year\",\n    y = \"Change in Number of Workers (compared to 2008)\",\n    color = \"Age Group\"\n  ) +\n  scale_y_continuous(\n    labels = scales::label_number(scale_cut = scales::cut_long_scale())\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1)\n  )\n\n\n\n\n\n\n\n\nThis plot shows the change in the number of workers in the 20-24 age group and the 60+ age group compared to 2008. We can see that the number of workers in the 20-24 age group has been decreasing over time, while the number of workers in the 60+ age group has been increasing. This further confirms that there is indeed an aging workforce in Indonesia.\nHow about the overall workforce, do we also see the same trend?\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Jumlah AK\",\n    month != \"Tahunan\"\n  ) |&gt;\n  group_by(age_group, month) |&gt;\n  mutate(value = value - value[year == 2008]) |&gt;\n  ungroup() |&gt;\n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n  facet_wrap(~month, scales = \"free_y\") +\n  geom_line(size = 1) +\n  geom_point(size = 2) +\n  scale_color_manual(values = c(\n    \"20-24\" = \"#E69F00\", # Muted orange\n    \"55-59\" = \"#56B4E9\", # Sky blue\n    \"60+\" = \"#009E73\" # Bluish green\n  )) +\n  labs(\n    title = \"Workforce in Indonesia by Age Group (2008-2025)\",\n    x = \"Year\",\n    y = \"Change in Number of Workers (compared to 2008)\",\n    color = \"Age Group\"\n  ) +\n  scale_y_continuous(\n    labels = scales::label_number(scale_cut = scales::cut_long_scale())\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1)\n  )\n\n\n\n\n\n\n\n\nThis plot shows the change in the total number of workers in the 20-24 age group and the 60+ age group compared to 2008. We can see that the number of workers in the 20-24 age group has been decreasing over time, while the number of workers in the 60+ age group has been increasing. This further confirms that there is indeed an aging workforce in Indonesia.\nBut, how about the unemployed?\n\nbps_data_tidy_labeled |&gt;\n  filter(\n    age_group %in% c(\"20-24\", \"55-59\", \"60+\"),\n    employment_status == \"Jumlah Pengangguran\",\n    month != \"Tahunan\"\n  ) |&gt;\n  group_by(age_group, month) |&gt;\n  mutate(value = value - value[year == 2008]) |&gt;\n  ungroup() |&gt;\n  ggplot(aes(x = year, y = value, color = age_group, group = age_group)) +\n  facet_wrap(~month, scales = \"free_y\") +\n  geom_line(size = 1) +\n  geom_point(size = 2) +\n  scale_color_manual(values = c(\n    \"20-24\" = \"#E69F00\", # Muted orange\n    \"55-59\" = \"#56B4E9\", # Sky blue\n    \"60+\" = \"#009E73\" # Bluish green\n  )) +\n  labs(\n    title = \"Unemployment in Indonesia by Age Group (2008-2025)\",\n    x = \"Year\",\n    y = \"Change in Number of Unemployed (compared to 2008)\",\n    color = \"Age Group\"\n  ) +\n  scale_y_continuous(\n    labels = scales::label_number(scale_cut = scales::cut_long_scale())\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1)\n  )"
  }
]